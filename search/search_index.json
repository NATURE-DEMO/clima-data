{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to clima-data","text":"<p><code>clima-data</code> is a Python library and collection of scripts designed for the NATURE-DEMO project as part of Work Packeage 2 (WP2). It provides tools for downloading and processing CORDEX (Coordinated Regional Climate Downscaling Experiment) data and calculating climate indices from regional climate model data.</p> <p>This documentation provides a guide to using the library, understanding the data it relies on, and exploring the climatic indicators it can generate.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Climate Data Access: Seamlessly download and process high-resolution regional climate projections from the CORDEX project.</li> <li>Climatic Indicators: Calculate a wide range of climatic indicators using the robust <code>xclim</code> library.</li> <li>Extensible and Modular: The library is designed to be easily extended with new climate models, regions, and indicators.</li> </ul>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<ul> <li>CORDEX Climate Data: Learn about the CORDEX regional climate projections, including the available models, variables, and how to download the data.</li> <li>Climatic Indicators: Explore the available climatic indicators, their definitions, and how to compute them using the library.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with <code>clima-data</code>, you'll need to set up your environment and download the necessary climate data.</p>"},{"location":"#setup","title":"Setup","text":"<ol> <li>Copernicus CDS Account: You'll need a Copernicus Climate Data Store (CDS) account to download CORDEX data. If you don't have one, you can sign up for free at the CDS website.</li> <li>API Key: Once you have an account, find your API key on your profile page and create a <code>.cdsapirc</code> file in your home directory with your credentials.</li> <li>Installation: Clone this repository and install the necessary dependencies using <code>make install</code>.</li> </ol> <p>For detailed setup instructions, please see the CORDEX Climate Data page.</p>"},{"location":"#project-acknowledgment","title":"Project Acknowledgment","text":"<p>This work is part of the NATURE-DEMO project, funded by the European Union's Horizon Europe research and innovation programme under grant agreement No. 101157448. </p> <p>NATURE-DEMO integrates nature-based solutions to enhance climate resilience for critical infrastructure across Europe.</p>"},{"location":"acknowledgments/","title":"Acknowledgments","text":""},{"location":"acknowledgments/#funding","title":"Funding","text":"<p>This work is part of the NATURE-DEMO project, funded by the European Union's Horizon Europe research and innovation programme under grant agreement No. 101157448.</p>"},{"location":"acknowledgments/#climate-data-sources","title":"Climate Data Sources","text":"<p>We gratefully acknowledge the following data providers and climate modeling initiatives:</p>"},{"location":"acknowledgments/#primary-data-sources","title":"Primary Data Sources","text":"<ul> <li>Copernicus Climate Data Store (CDS): The European Union's Earth observation programme, providing access to comprehensive climate data.</li> <li>CORDEX (Coordinated Regional Climate Downscaling Experiment): The World Climate Research Programme's framework for coordinated regional climate downscaling.</li> <li>EURO-CORDEX: The European domain of CORDEX, providing high-resolution regional climate projections for Europe.</li> <li>Earth System Grid Federation (ESGF): The international collaboration for climate model data distribution and access.</li> </ul>"},{"location":"acknowledgments/#scientific-libraries-and-software","title":"Scientific Libraries and Software","text":"<p>This work builds upon the outstanding contributions of the scientific Python community:</p>"},{"location":"acknowledgments/#core-climate-science-libraries","title":"Core Climate Science Libraries","text":"<ul> <li>xclim: Climate indices calculation library, essential for computing climate indicators.</li> <li>xarray: Multi-dimensional array processing for climate data analysis.</li> <li>netCDF4: Python interface to the netCDF C library for handling climate data files.</li> </ul>"},{"location":"acknowledgments/#geospatial-and-data-processing","title":"Geospatial and Data Processing","text":"<ul> <li>cartopy: Geospatial data processing and cartographic projections.</li> <li>geopandas: Geographic data analysis in Python.</li> <li>dask: Parallel computing for large-scale climate data processing.</li> <li>zarr: Chunked, compressed, N-dimensional arrays.</li> </ul>"},{"location":"acknowledgments/#climate-risk-assessment-framework","title":"Climate Risk Assessment Framework","text":"<p>We acknowledge the CLIMAAX project (CLIMAte risk and vulnerability Assessment framework and toolboX), funded by the European Union's Horizon Europe research and innovation programme under grant agreement No. 101093864. CLIMAAX develops standardized climate risk assessment frameworks and toolboxes that support consistent and accessible climate risk analysis across European regions.</p>"},{"location":"acknowledgments/#attribution","title":"Attribution","text":"<p>This software is designed to facilitate climate research and support nature-based solutions for infrastructure resilience. We encourage users to cite the relevant datasets, model outputs, and software libraries when using results derived from this tool.</p> <p>For specific dataset citations, please refer to the individual data provider's requirements and our Bibliography section.</p> <p>The NATURE-DEMO project integrates nature-based solutions to enhance climate resilience for critical infrastructure across Europe.</p>"},{"location":"cordex/","title":"CORDEX Regional Climate Projections","text":""},{"location":"cordex/#climate-models-and-climatic-indices","title":"Climate Models and Climatic Indices","text":"<p>Climate models are sophisticated computational tools that simulate Earth's climate system by integrating physical, chemical, and biological processes across the atmosphere, oceans, land, and ice. These models, ranging from global (GCMs) to regional (RCMs) scales, use mathematical equations to represent interactions such as energy transfer, ocean currents, and greenhouse gas effects. By projecting future scenarios under varying emissions pathways (e.g., RCPs or SSPs), they generate data on key variables like temperature, precipitation, and wind. These outputs feed into climatic indices\u2014metrics such as heatwave frequency, drought severity, or extreme rainfall return periods\u2014that quantify specific climate risks.</p> <p>CORDEX provides high-resolution regional climate projections essential for assessing localized climate impacts across 14 continent-scale domains, including Europe (Diez-Sierra et al. 2022)<sup>1</sup>. The climatic indices provided by such projections are vital for policymakers, guiding adaptation strategies and resilience planning in sectors like agriculture, hydrology, and urban development.</p>"},{"location":"cordex/#global-climate-models-gcms","title":"Global Climate Models (GCMs)","text":"<p>Several studies have evaluated and ranked CMIP5 Global Climate Models (GCMs) used in EURO-CORDEX based on their ability to simulate historical climate and provide reliable boundary conditions for regional downscaling. Based on (Jury et al. 2015)<sup>2</sup>, we select a subset of GCMs as top performers for EURO-CORDEX.</p>"},{"location":"cordex/#regional-climate-models-rcms","title":"Regional Climate Models (RCMs)","text":"<p>Based on evaluations from the EURO-CORDEX ensemble and peer-reviewed studies, there is no universal \"best\" regional climate model (RCM), but consensus exists on top-performing models for specific variables and regions (Kotlarski et al. 2015; Coppola et al. 2021)<sup>3</sup> <sup>4</sup>.</p>"},{"location":"cordex/#cordex-variables","title":"CORDEX Variables","text":"<p>The table below provides a partial list of variables available in EURO-CORDEX \u2014 such as near-surface temperature (<code>tas</code>), precipitation (<code>pr</code>), and wind speed (<code>sfcWind</code>). The complete list is available in the CORDEX Variable Requirements document. These variables serve as foundational inputs for deriving critical climatic indices, ranging from heatwave duration (<code>tx40_cdd</code>) to extreme precipitation return periods (<code>r100yrRP</code>), which quantify climate extremes and trends, enabling researchers and policymakers to evaluate risks like droughts, floods, and temperature anomalies. By leveraging these standardized variables, stakeholders can perform robust, region-specific analyses to inform adaptation strategies and resilience planning under evolving climate scenarios.</p> Variable Name (CDS) Short Name Units Description 10m u-component of the wind <code>uas</code> m s\u207b\u00b9 Eastward wind component at 10m above the surface 10m v-component of the wind <code>vas</code> m s\u207b\u00b9 Northward wind component at 10m above the surface 10m wind speed <code>sfcWind</code> m s\u207b\u00b9 Magnitude of horizontal wind speed at 10m above the surface 200hPa temperature <code>ta200</code> K Air temperature at the 200hPa pressure level 200hPa u-component of the wind <code>ua200</code> m s\u207b\u00b9 Eastward wind component at 200hPa 200hPa v-component of the wind <code>va200</code> m s\u207b\u00b9 Northward wind component at 200hPa 2m air temperature <code>tas</code> K Near-surface air temperature at 2m above ground 2m relative humidity <code>hurs</code> % Relative humidity at 2m above ground 2m surface specific humidity <code>huss</code> Dimensionless Specific humidity (mass of water vapor per unit mass of air) at 2m 500hPa geopotential height <code>zg500</code> m Gravitational potential energy per unit mass at 500hPa 850hPa u-component of the wind <code>ua850</code> m s\u207b\u00b9 Eastward wind component at 850hPa 850hPa v-component of the wind <code>va850</code> m s\u207b\u00b9 Northward wind component at 850hPa Evaporation <code>evspsbl</code> kg m\u207b\u00b2 s\u207b\u00b9 Mass of liquid water evaporating from land (includes sublimation) Land area fraction <code>sftlf</code> % Fraction of grid cell occupied by land Maximum 2m temperature in the last 24 hours <code>tasmax</code> K Daily maximum temperature at 2m above the surface Mean precipitation flux <code>pr</code> kg m\u207b\u00b2 s\u207b\u00b9 Deposition of water (rain, snow, ice, hail) to the Earth's surface Mean sea level pressure <code>psl</code> Pa Air pressure adjusted to sea level Minimum 2m temperature in the last 24 hours <code>tasmin</code> K Daily minimum temperature at 2m above the surface Orography <code>orog</code> m Surface elevation (0.0 over oceans) Surface pressure <code>ps</code> Pa Air pressure at the lower boundary of the atmosphere Surface solar radiation downwards <code>rsds</code> W m\u207b\u00b2 Downward shortwave radiative flux at the surface Surface thermal radiation downward <code>rlds</code> W m\u207b\u00b2 Downward longwave radiative flux at the surface Surface upwelling shortwave radiation <code>rsus</code> W m\u207b\u00b2 Upward shortwave radiative flux from the surface Total cloud cover <code>clt</code> Dimensionless Fraction of the sky covered by clouds (whole atmospheric column) Total run-off flux <code>mrro</code> kg m\u207b\u00b2 s\u207b\u00b9 Combined surface and subsurface liquid water draining from land"},{"location":"cordex/#notes","title":"Notes","text":"<ul> <li>Units: Align with CORDEX/CDS specifications (e.g., <code>pr</code> in <code>kg.m\u207b\u00b2.s\u207b\u00b9</code>, <code>tas</code> in <code>K</code>)</li> <li>Temporal resolution: Variables are available at 3-hourly, daily, monthly, or seasonal frequencies, which in the CDS API are indicated as <code>3hr</code>, <code>daily_mean</code>, <code>monthly_mean</code>, <code>seasonal_mean</code>, respectively (non-European domains only include daily data).</li> <li>Static variables: <code>sftlf</code> (land area fraction) and <code>orog</code> (topography) are time-independent</li> <li>Standard Names: Standard naming following CF conventions can be found in CORDEX Variable Requirements Table</li> </ul> <p>For further details, see the CORDEX Documentation.</p>"},{"location":"cordex/#downloading-cordex-data","title":"Downloading CORDEX data","text":"<p>To download all the CORDEX data necessary to compute climatic indices and indicators useful to NATURE-DEMO, make sure to set up a Copernicus Climate Data Store (CDS) account as explained in the main page. Then run the following script:</p> <pre><code>python scripts/download_cordex_data.py\n</code></pre> <p>This will take a long time (~24h), since it will download a lot of data (~5TB). The data will be downloaded to the folder <code>~/data/cordex</code>. That path can be changed by modifying the <code>DATADIR</code> variable in the script.</p> <p>This download script uses the code in the module <code>clima_data.cordex</code>, which provides a convenient interface to the Copernicus Climate Data Store (CDS) API for downloading CORDEX data and is documented below.</p>"},{"location":"cordex/#code-documentation-clima_datacordex","title":"Code documentation <code>clima_data.cordex</code>","text":""},{"location":"cordex/#cordex.TIME_FRAMES","title":"<code>TIME_FRAMES = {'his': {'historical': [1976, 2005]}, 'rcp': {'short': [2011, 2040], 'medium': [2041, 2070], 'long': [2071, 2100]}}</code>  <code>module-attribute</code>","text":"<p>Time frames for EURO-CORDEX data</p> <p>Definition of the time frames used in analysing EURO-CORDEX data and computing climate indices and climate indicators.</p>"},{"location":"cordex/#cordex.CordexNames","title":"<code>CordexNames</code>","text":"<p>Centralized registry for CORDEX climate model naming formats and conversions.</p> <p>Handles conversion between different naming conventions used by: - Input/keys: Short lowercase keys for easy use - ESGF: Used in ESGF table and GCM parts of downloaded filenames - CDS: Used in CDS API requests (lowercase with underscores) - Filenames: Used in downloaded filenames (hybrid format)</p> Source code in <code>clima_data/cordex.py</code> <pre><code>class CordexNames:\n    r\"\"\"Centralized registry for CORDEX climate model naming formats and conversions.\n\n    Handles conversion between different naming conventions used by:\n    - Input/keys: Short lowercase keys for easy use\n    - ESGF: Used in ESGF table and GCM parts of downloaded filenames\n    - CDS: Used in CDS API requests (lowercase with underscores)\n    - Filenames: Used in downloaded filenames (hybrid format)\n    \"\"\"\n\n    # EURO-CORDEX coordinate system parameters\n    CORDEX_CRS = ccrs.RotatedPole(pole_latitude=39.25, pole_longitude=-162)\n    WGS84_TO_CORDEX_TRANS = pyproj.Transformer.from_crs(\"epsg:4326\", CORDEX_CRS)\n\n    # Global Climate Models - mapping from short keys to various formats\n    GCMS = {\n        \"ichec\": {\n            \"input\": \"ICHEC-EC-EARTH\",\n            \"esgf\": \"ICHEC-EC-EARTH\",\n            \"cds\": \"ichec_ec_earth\",\n        },\n        \"mpi\": {\n            \"input\": \"MPI-M-MPI-ESM-LR\",\n            \"esgf\": \"MPI-M-MPI-ESM-LR\",\n            \"cds\": \"mpi_m_mpi_esm_lr\",\n        },\n        \"cnrm\": {\n            \"input\": \"CNRM-CERFACS-CM5\",\n            \"esgf\": \"CNRM-CERFACS-CNRM-CM5\",\n            \"cds\": \"cnrm_cerfacs_cm5\",\n        },\n        \"hadgem\": {\n            \"input\": \"MOHC-HadGEM2-ES\",\n            \"esgf\": \"MOHC-HadGEM2-ES\",\n            \"cds\": \"mohc_hadgem2_es\",\n        },\n    }\n\n    # Regional Climate Models - mapping from short keys to various formats\n    RCMS = {\n        \"racmo\": {\n            \"input\": \"KNMI-RACMO22E\",\n            \"esgf\": \"RACMO22E\",\n            \"cds\": \"knmi_racmo22e\",\n        },\n        \"rca4\": {\n            \"input\": \"SMHI-RCA4\",\n            \"esgf\": \"RCA4\",\n            \"cds\": \"smhi_rca4\",\n        },\n        \"remo\": {\n            \"input\": \"GERICS-REMO2015\",\n            \"esgf\": \"REMO2015\",\n            \"cds\": \"gerics_remo2015\",\n        },\n        \"cosmo\": {\n            \"input\": \"CLMcom-ETH-COSMO-crCLIM\",\n            \"esgf\": \"COSMO-crCLIM-v1-1\",\n            \"cds\": \"clmcom_eth_cosmo_crclim\",\n        },\n    }\n\n    # Variables - mapping from input names to various formats\n    VARIABLES = {\n        \"tas\": {\n            \"input\": \"tas\",\n            \"esgf\": \"tas\",\n            \"cds\": \"2m_air_temperature\",\n        },\n        \"sfcWind\": {\n            \"input\": \"sfcWind\",\n            \"esgf\": \"sfcWind\",\n            \"cds\": \"10m_wind_speed\",\n        },\n        \"tasmax\": {\n            \"input\": \"tasmax\",\n            \"esgf\": \"tasmax\",\n            \"cds\": \"maximum_2m_temperature_in_the_last_24_hours\",\n        },\n        \"tasmin\": {\n            \"input\": \"tasmin\",\n            \"esgf\": \"tasmin\",\n            \"cds\": \"minimum_2m_temperature_in_the_last_24_hours\",\n        },\n        \"pr\": {\n            \"input\": \"pr\",\n            \"esgf\": \"pr\",\n            \"cds\": \"mean_precipitation_flux\",\n        },\n        \"uas\": {\n            \"input\": \"uas\",\n            \"esgf\": \"uas\",\n            \"cds\": \"10m_u_component_of_the_wind\",\n        },\n        \"vas\": {\n            \"input\": \"vas\",\n            \"esgf\": \"vas\",\n            \"cds\": \"10m_v_component_of_the_wind\",\n        },\n        \"ta200\": {\n            \"input\": \"ta200\",\n            \"esgf\": \"ta200\",\n            \"cds\": \"200hpa_temperature\",\n        },\n        \"ua200\": {\n            \"input\": \"ua200\",\n            \"esgf\": \"ua200\",\n            \"cds\": \"200hpa_u_component_of_the_wind\",\n        },\n        \"va200\": {\n            \"input\": \"va200\",\n            \"esgf\": \"va200\",\n            \"cds\": \"200hpa_v_component_of_the_wind\",\n        },\n        \"hurs\": {\n            \"input\": \"hurs\",\n            \"esgf\": \"hurs\",\n            \"cds\": \"2m_relative_humidity\",\n        },\n        \"huss\": {\n            \"input\": \"huss\",\n            \"esgf\": \"huss\",\n            \"cds\": \"2m_surface_specific_humidity\",\n        },\n        \"zg500\": {\n            \"input\": \"zg500\",\n            \"esgf\": \"zg500\",\n            \"cds\": \"500hpa_geopotential_height\",\n        },\n        \"ua850\": {\n            \"input\": \"ua850\",\n            \"esgf\": \"ua850\",\n            \"cds\": \"850hpa_u_component_of_the_wind\",\n        },\n        \"va850\": {\n            \"input\": \"va850\",\n            \"esgf\": \"va850\",\n            \"cds\": \"850hpa_v_component_of_the_wind\",\n        },\n        \"evspsbl\": {\n            \"input\": \"evspsbl\",\n            \"esgf\": \"evspsbl\",\n            \"cds\": \"evaporation\",\n        },\n        \"sftlf\": {\n            \"input\": \"sftlf\",\n            \"esgf\": \"sftlf\",\n            \"cds\": \"land_area_fraction\",\n        },\n        \"psl\": {\n            \"input\": \"psl\",\n            \"esgf\": \"psl\",\n            \"cds\": \"mean_sea_level_pressure\",\n        },\n        \"orog\": {\n            \"input\": \"orog\",\n            \"esgf\": \"orog\",\n            \"cds\": \"orography\",\n        },\n        \"ps\": {\n            \"input\": \"ps\",\n            \"esgf\": \"ps\",\n            \"cds\": \"surface_pressure\",\n        },\n        \"rsds\": {\n            \"input\": \"rsds\",\n            \"esgf\": \"rsds\",\n            \"cds\": \"surface_solar_radiation_downwards\",\n        },\n        \"rlds\": {\n            \"input\": \"rlds\",\n            \"esgf\": \"rlds\",\n            \"cds\": \"surface_thermal_radiation_downward\",\n        },\n        \"rsus\": {\n            \"input\": \"rsus\",\n            \"esgf\": \"rsus\",\n            \"cds\": \"surface_upwelling_shortwave_radiation\",\n        },\n        \"clt\": {\n            \"input\": \"clt\",\n            \"esgf\": \"clt\",\n            \"cds\": \"total_cloud_cover\",\n        },\n        \"mrro\": {\n            \"input\": \"mrro\",\n            \"esgf\": \"mrro\",\n            \"cds\": \"total_run_off_flux\",\n        },\n    }\n\n    # Frequencies - mapping from input names to various formats\n    FREQUENCIES = {\n        \"3hr\": {\n            \"input\": \"3hr\",\n            \"esgf\": \"3hr\",\n            \"cds\": \"3_hours\",\n        },\n        \"6hr\": {\n            \"input\": \"6hr\",\n            \"esgf\": \"6hr\",\n            \"cds\": \"6_hours\",\n        },\n        \"day\": {\n            \"input\": \"day\",\n            \"esgf\": \"day\",\n            \"cds\": \"daily_mean\",\n        },\n        \"mon\": {\n            \"input\": \"mon\",\n            \"esgf\": \"mon\",\n            \"cds\": \"monthly_mean\",\n        },\n        \"sea\": {\n            \"input\": \"sea\",\n            \"esgf\": \"sea\",\n            \"cds\": \"seasonal_mean\",\n        },\n    }\n\n    # Experiments - mapping from input names to various formats\n    EXPERIMENTS = {\n        \"historical\": {\n            \"input\": \"historical\",\n            \"esgf\": \"historical\",\n            \"cds\": \"historical\",\n        },\n        \"rcp25\": {\n            \"input\": \"rcp25\",\n            \"esgf\": \"rcp25\",\n            \"cds\": \"rcp_2_5\",\n        },\n        \"rcp45\": {\n            \"input\": \"rcp45\",\n            \"esgf\": \"rcp45\",\n            \"cds\": \"rcp_4_5\",\n        },\n        \"rcp85\": {\n            \"input\": \"rcp85\",\n            \"esgf\": \"rcp85\",\n            \"cds\": \"rcp_8_5\",\n        },\n    }\n\n    @classmethod\n    def get_gcm_name(cls, key: str, format: str) -&gt; str:\n        \"\"\"Get GCM name in specified format. Returns input if no match found.\"\"\"\n        if key not in cls.GCMS:\n            return key\n        if format not in cls.GCMS[key]:\n            return key\n        return cls.GCMS[key][format]\n\n    @classmethod\n    def get_rcm_name(cls, key: str, format: str) -&gt; str:\n        \"\"\"Get RCM name in specified format. Returns input if no match found.\"\"\"\n        if key not in cls.RCMS:\n            return key\n        if format not in cls.RCMS[key]:\n            return key\n        return cls.RCMS[key][format]\n\n    @classmethod\n    def get_variable_name(cls, name: str, format: str) -&gt; str:\n        \"\"\"Get variable name in specified format. Returns input if no match found.\"\"\"\n        if name not in cls.VARIABLES:\n            return name\n        if format not in cls.VARIABLES[name]:\n            return name\n        return cls.VARIABLES[name][format]\n\n    @classmethod\n    def get_frequency_name(cls, name: str, format: str) -&gt; str:\n        \"\"\"Get frequency name in specified format. Returns input if no match found.\"\"\"\n        if name not in cls.FREQUENCIES:\n            return name\n        if format not in cls.FREQUENCIES[name]:\n            return name\n        return cls.FREQUENCIES[name][format]\n\n    @classmethod\n    def get_experiment_name(cls, name: str, format: str) -&gt; str:\n        \"\"\"Get experiment name in specified format. Returns input if no match found.\"\"\"\n        if name not in cls.EXPERIMENTS:\n            return name\n        if format not in cls.EXPERIMENTS[name]:\n            return name\n        return cls.EXPERIMENTS[name][format]\n\n    @classmethod\n    def get_filename_gcm(cls, key: str) -&gt; str:\n        \"\"\"Get GCM name as it appears in downloaded filenames (ESGF format).\"\"\"\n        return cls.get_gcm_name(key, \"esgf\")\n\n    @classmethod\n    def get_filename_rcm(cls, key: str) -&gt; str:\n        \"\"\"Get RCM name as it appears in downloaded filenames (input format).\"\"\"\n        return cls.get_rcm_name(key, \"input\")\n\n    @classmethod\n    def list_gcms(cls) -&gt; list[str]:\n        \"\"\"Get list of all supported GCM keys.\"\"\"\n        return list(cls.GCMS.keys())\n\n    @classmethod\n    def list_rcms(cls) -&gt; list[str]:\n        \"\"\"Get list of all supported RCM keys.\"\"\"\n        return list(cls.RCMS.keys())\n\n    @classmethod\n    def list_variables(cls) -&gt; list[str]:\n        \"\"\"Get list of all supported variable names.\"\"\"\n        return list(cls.VARIABLES.keys())\n\n    @classmethod\n    def list_frequencies(cls) -&gt; list[str]:\n        \"\"\"Get list of all supported frequency names.\"\"\"\n        return list(cls.FREQUENCIES.keys())\n\n    @classmethod\n    def list_experiments(cls) -&gt; list[str]:\n        \"\"\"Get list of all supported experiment names.\"\"\"\n        return list(cls.EXPERIMENTS.keys())\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_experiment_name","title":"<code>get_experiment_name(name, format)</code>  <code>classmethod</code>","text":"<p>Get experiment name in specified format. Returns input if no match found.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_experiment_name(cls, name: str, format: str) -&gt; str:\n    \"\"\"Get experiment name in specified format. Returns input if no match found.\"\"\"\n    if name not in cls.EXPERIMENTS:\n        return name\n    if format not in cls.EXPERIMENTS[name]:\n        return name\n    return cls.EXPERIMENTS[name][format]\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_filename_gcm","title":"<code>get_filename_gcm(key)</code>  <code>classmethod</code>","text":"<p>Get GCM name as it appears in downloaded filenames (ESGF format).</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_filename_gcm(cls, key: str) -&gt; str:\n    \"\"\"Get GCM name as it appears in downloaded filenames (ESGF format).\"\"\"\n    return cls.get_gcm_name(key, \"esgf\")\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_filename_rcm","title":"<code>get_filename_rcm(key)</code>  <code>classmethod</code>","text":"<p>Get RCM name as it appears in downloaded filenames (input format).</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_filename_rcm(cls, key: str) -&gt; str:\n    \"\"\"Get RCM name as it appears in downloaded filenames (input format).\"\"\"\n    return cls.get_rcm_name(key, \"input\")\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_frequency_name","title":"<code>get_frequency_name(name, format)</code>  <code>classmethod</code>","text":"<p>Get frequency name in specified format. Returns input if no match found.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_frequency_name(cls, name: str, format: str) -&gt; str:\n    \"\"\"Get frequency name in specified format. Returns input if no match found.\"\"\"\n    if name not in cls.FREQUENCIES:\n        return name\n    if format not in cls.FREQUENCIES[name]:\n        return name\n    return cls.FREQUENCIES[name][format]\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_gcm_name","title":"<code>get_gcm_name(key, format)</code>  <code>classmethod</code>","text":"<p>Get GCM name in specified format. Returns input if no match found.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_gcm_name(cls, key: str, format: str) -&gt; str:\n    \"\"\"Get GCM name in specified format. Returns input if no match found.\"\"\"\n    if key not in cls.GCMS:\n        return key\n    if format not in cls.GCMS[key]:\n        return key\n    return cls.GCMS[key][format]\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_rcm_name","title":"<code>get_rcm_name(key, format)</code>  <code>classmethod</code>","text":"<p>Get RCM name in specified format. Returns input if no match found.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_rcm_name(cls, key: str, format: str) -&gt; str:\n    \"\"\"Get RCM name in specified format. Returns input if no match found.\"\"\"\n    if key not in cls.RCMS:\n        return key\n    if format not in cls.RCMS[key]:\n        return key\n    return cls.RCMS[key][format]\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.get_variable_name","title":"<code>get_variable_name(name, format)</code>  <code>classmethod</code>","text":"<p>Get variable name in specified format. Returns input if no match found.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef get_variable_name(cls, name: str, format: str) -&gt; str:\n    \"\"\"Get variable name in specified format. Returns input if no match found.\"\"\"\n    if name not in cls.VARIABLES:\n        return name\n    if format not in cls.VARIABLES[name]:\n        return name\n    return cls.VARIABLES[name][format]\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.list_experiments","title":"<code>list_experiments()</code>  <code>classmethod</code>","text":"<p>Get list of all supported experiment names.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef list_experiments(cls) -&gt; list[str]:\n    \"\"\"Get list of all supported experiment names.\"\"\"\n    return list(cls.EXPERIMENTS.keys())\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.list_frequencies","title":"<code>list_frequencies()</code>  <code>classmethod</code>","text":"<p>Get list of all supported frequency names.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef list_frequencies(cls) -&gt; list[str]:\n    \"\"\"Get list of all supported frequency names.\"\"\"\n    return list(cls.FREQUENCIES.keys())\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.list_gcms","title":"<code>list_gcms()</code>  <code>classmethod</code>","text":"<p>Get list of all supported GCM keys.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef list_gcms(cls) -&gt; list[str]:\n    \"\"\"Get list of all supported GCM keys.\"\"\"\n    return list(cls.GCMS.keys())\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.list_rcms","title":"<code>list_rcms()</code>  <code>classmethod</code>","text":"<p>Get list of all supported RCM keys.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef list_rcms(cls) -&gt; list[str]:\n    \"\"\"Get list of all supported RCM keys.\"\"\"\n    return list(cls.RCMS.keys())\n</code></pre>"},{"location":"cordex/#cordex.CordexNames.list_variables","title":"<code>list_variables()</code>  <code>classmethod</code>","text":"<p>Get list of all supported variable names.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>@classmethod\ndef list_variables(cls) -&gt; list[str]:\n    \"\"\"Get list of all supported variable names.\"\"\"\n    return list(cls.VARIABLES.keys())\n</code></pre>"},{"location":"cordex/#cordex.cordex_data_check","title":"<code>cordex_data_check(filepath)</code>","text":"<p>Lightweight quality check for CDS CORDEX data</p> Source code in <code>clima_data/cordex.py</code> <pre><code>def cordex_data_check(filepath: str) -&gt; list:\n    \"\"\"Lightweight quality check for CDS CORDEX data\"\"\"\n    ds = xr.open_dataset(filepath)\n\n    # Quick data content checks (since metadata is already validated by CDS)\n    issues = []\n    for var_name, var in ds.data_vars.items():\n        # Check for obvious data issues\n        if var.isnull().all():\n            issues.append(f\"{var_name}: All values are NaN\")\n            continue\n\n        # Use xclim for variable-specific checks\n        flags = data_flags(var, ds=ds)\n        if flags is not None:\n            # flags is a Dataset with boolean scalar values for each check\n            failed_checks = []\n            for check_name, check_result in flags.data_vars.items():\n                if check_result.item():  # .item() extracts the boolean value\n                    failed_checks.append(check_name)\n            if failed_checks:\n                issues.append(f\"{var_name}: Failed checks - {', '.join(failed_checks)}\")\n    ds.close()\n    return issues\n</code></pre>"},{"location":"cordex/#cordex.download_cordex","title":"<code>download_cordex(variable, gcm_model, rcm_model, experiment, freq, year_start, year_end, data_dir, verbose=False)</code>","text":"<p>Worker function handling CDS download and file processing</p> Source code in <code>clima_data/cordex.py</code> <pre><code>def download_cordex(\n    variable: str,\n    gcm_model: str,\n    rcm_model: str,\n    experiment: str,\n    freq: str,\n    year_start: int,\n    year_end: int,\n    data_dir: str,\n    verbose: bool = False,\n) -&gt; str:\n    \"\"\"Worker function handling CDS download and file processing\"\"\"\n\n    # Check that all parameters are valid\n    assert experiment in CordexNames.EXPERIMENTS, f\"Invalid experiment name: {experiment}\"\n\n    # Configure paths\n    filename = get_filename(variable, gcm_model, rcm_model, experiment, freq, year_start, year_end)\n    dir_path = get_dirpath(data_dir, variable, experiment, freq)\n    zip_path = os.path.join(dir_path, f\"{filename.replace('*', 'X')}.zip\")\n    os.makedirs(dir_path, exist_ok=True)\n\n    # Check if files already exist before downloading\n    existing_files = _check_existing_files(\n        dir_path, variable, gcm_model, rcm_model, experiment, freq, year_start, year_end\n    )\n    if existing_files:\n        return f\"Already exists: {existing_files[0]}. SKIPPING.\"\n\n    # Create unique client instance per thread\n    client = cdsapi.Client()  # url and key are looked up in ~/.cdsapirc\n\n    # Build CDS API request\n    request = _build_cds_request(\n        variable, gcm_model, rcm_model, experiment, freq, year_start, year_end\n    )\n    if verbose:\n        print(f\"Requesting {filename} with parameters: {request}\")\n\n    try:\n        client.retrieve(\n            \"projections-cordex-domains-single-levels\",\n            request,\n            zip_path,\n        )\n\n        # Process downloaded files\n        with zipfile.ZipFile(zip_path, \"r\") as z:\n            z.extractall(dir_path)\n        os.remove(zip_path)\n        return f\"Success: {filename}.nc\"\n    except Exception as e:\n        return f\"Failed to download {filename}: {e!s}\"\n</code></pre>"},{"location":"cordex/#cordex.get_esgf_combinations_for_experiment","title":"<code>get_esgf_combinations_for_experiment(experiment, variable=None, frequency=None)</code>","text":"<p>Get available combinations from ESGF for specific experiment with optional filtering</p> <p>Parameters:</p> Name Type Description Default <code>experiment</code> <code>str</code> <p>Experiment ID (e.g., 'historical', 'rcp45', 'rcp85')</p> required <code>variable</code> <code>str | None</code> <p>Optional variable name to filter by</p> <code>None</code> <code>frequency</code> <code>str | None</code> <p>Optional frequency to filter by (e.g., 'day', 'mon')</p> <code>None</code> <p>Returns:</p> Type Description <code>set[tuple[str, str, str, str]]</code> <p>Set of tuples containing (gcm, rcm, variable, frequency) for valid combinations</p> Source code in <code>clima_data/cordex.py</code> <pre><code>def get_esgf_combinations_for_experiment(\n    experiment: str, variable: str | None = None, frequency: str | None = None\n) -&gt; set[tuple[str, str, str, str]]:\n    \"\"\"Get available combinations from ESGF for specific experiment with optional filtering\n\n    Args:\n        experiment: Experiment ID (e.g., 'historical', 'rcp45', 'rcp85')\n        variable: Optional variable name to filter by\n        frequency: Optional frequency to filter by (e.g., 'day', 'mon')\n\n    Returns:\n        Set of tuples containing (gcm, rcm, variable, frequency) for valid combinations\n    \"\"\"\n\n    try:\n        print(f\"Querying ESGF data for experiment: {experiment}\")\n        if variable:\n            print(f\"  Filtering by variable: {variable}\")\n        if frequency:\n            print(f\"  Filtering by frequency: {frequency}\")\n\n        df = _get_esgf_data()\n\n        # Filter by experiment\n        filtered_data = df[df[\"experiment_id\"] == experiment]\n        if filtered_data.empty:\n            print(f\"Warning: No data found for experiment '{experiment}' in ESGF table\")\n            return set()\n\n        # Apply additional filters if provided\n        if variable:\n            filtered_data = filtered_data[filtered_data[\"variable\"] == variable]\n            if filtered_data.empty:\n                print(\n                    f\"Warning: No data found for variable '{variable}' in experiment '{experiment}'\"\n                )\n                return set()\n\n        if frequency:\n            filtered_data = filtered_data[filtered_data[\"frequency\"] == frequency]\n            if filtered_data.empty:\n                print(\n                    f\"Warning: No data found for frequency '{frequency}' in experiment '{experiment}'\"\n                )\n                return set()\n\n        # Extract unique combinations with all relevant parameters\n        combinations = set()\n        unique_combinations = filtered_data[\n            [\"driving_model_id\", \"model_id\", \"variable\", \"frequency\"]\n        ].drop_duplicates()\n\n        for _, row in unique_combinations.iterrows():\n            gcm = row[\"driving_model_id\"]\n            rcm = row[\"model_id\"]\n            var = row[\"variable\"]\n            freq = row[\"frequency\"]\n            combinations.add((gcm, rcm, var, freq))\n\n        print(f\"Found {len(combinations)} unique combinations for {experiment}\")\n        return combinations\n\n    except pd.errors.EmptyDataError:\n        print(\"Error: ESGF CSV file is empty or malformed\")\n        return set()\n    except pd.errors.ParserError as e:\n        print(f\"Error: Could not parse ESGF CSV file: {e}\")\n        return set()\n    except Exception as e:\n        print(f\"Warning: Could not fetch ESGF data for {experiment}: {e}\")\n        print(\"All tasks will be pruned - no combinations available\")\n        return set()\n</code></pre>"},{"location":"cordex/#cordex.get_filename","title":"<code>get_filename(variable, gcm_model, rcm_model, experiment, freq, year_start, year_end)</code>","text":"<p>File name for the downloaded data based on the parameters provided</p> <p>Return file name following the CDS API naming convention for CORDEX data explained at https://confluence.ecmwf.int/display/CKB/CORDEX%3A+Regional+climate+projections:</p> <p><code>&lt;variable&gt;_&lt;domain&gt;_&lt;driving-model&gt;_&lt;experiment&gt;_&lt;ensemble_member&gt;_&lt;rcm-model&gt;_&lt;rcm-run&gt;_&lt;time-frequency&gt;_&lt;temporal-range&gt;.nc</code></p> Where <ul> <li> is a short variable name, e.g. \u201ctas\u201d for \u201ctemperature at the surface\u201d <li> is \"EUR-11\" for EURO-CORDEX data <li> is the GCM model that produced the boundary conditions <li> is the name of the experiment used to extract the boundary conditions (historical, rcp45, rcp85) <li> is the ensemble identifier in the form \u201crip\u201d, X, Y and Z are integers <li> is the name of the model that produced the data <li> is the version run of the model in the form of \"vX\" where X is integer <li> is the time series frequency (e.g., monthly, daily, seasonal) <li>the  is in the form YYYYMM[DDHH]-YYYY[MMDDHH], where Y is year, M is the month, D is day and H is hour. Note that day and hour are optional (indicated by the square brackets) and are only used if needed by the frequency of the data. For example daily data from the 1st of January 1980 to the 31st of December 2010 would be written 19800101-20101231. Source code in <code>clima_data/cordex.py</code> <pre><code>def get_filename(\n    variable: str,\n    gcm_model: str,\n    rcm_model: str,\n    experiment: str,\n    freq: str,\n    year_start: int | None,\n    year_end: int | None,\n) -&gt; str:\n    \"\"\"File name for the downloaded data based on the parameters provided\n\n    Return file name following the CDS API naming convention for CORDEX data explained\n    at &lt;https://confluence.ecmwf.int/display/CKB/CORDEX%3A+Regional+climate+projections&gt;:\n\n    `&lt;variable&gt;_&lt;domain&gt;_&lt;driving-model&gt;_&lt;experiment&gt;_&lt;ensemble_member&gt;_&lt;rcm-model&gt;_&lt;rcm-run&gt;_&lt;time-frequency&gt;_&lt;temporal-range&gt;.nc`\n\n    Where:\n        - &lt;variable&gt; is a short variable name, e.g. \u201ctas\u201d for \u201ctemperature at the surface\u201d\n        - &lt;domain&gt; is \"EUR-11\" for EURO-CORDEX data\n        - &lt;driving-model&gt; is the GCM model that produced the boundary conditions\n        - &lt;experiment&gt; is the name of the experiment used to extract the boundary conditions (historical, rcp45, rcp85)\n        - &lt;ensemble-member&gt; is the ensemble identifier in the form \u201cr&lt;X&gt;i&lt;Y&gt;p&lt;Z&gt;\u201d, X, Y and Z are integers\n        - &lt;rcm-model&gt; is the name of the model that produced the data\n        - &lt;rcm-run&gt; is the version run of the model in the form of \"vX\" where X is integer\n        - &lt;time-frequency&gt; is the time series frequency (e.g., monthly, daily, seasonal)\n        - the &lt;temporal-range&gt; is in the form YYYYMM[DDHH]-YYYY[MMDDHH], where Y is year, M is the month, D is day and H is hour. Note that day and hour are optional (indicated by the square brackets) and are only used if needed by the frequency of the data. For example daily data from the 1st of January 1980 to the 31st of December 2010 would be written 19800101-20101231.\n    \"\"\"\n    assert variable in CordexNames.VARIABLES, f\"Invalid variable name: {variable}\"\n    domain = \"EUR-11\"\n\n    # Convert to ESGF format for filename (returns input if not found)\n    if gcm_model != \"*\":\n        gcm_model = CordexNames.get_gcm_name(gcm_model, \"esgf\")\n\n    assert experiment in CordexNames.EXPERIMENTS, f\"Invalid experiment name: {experiment}\"\n    ensemble = \"r1i1p1\"\n\n    if rcm_model != \"*\":\n        rcm_model = CordexNames.get_rcm_name(rcm_model, \"input\")\n\n    rcm_run = \"v*\"\n\n    assert freq in CordexNames.FREQUENCIES, f\"Invalid frequency name: {freq}\"\n    if freq in [\"3hr\", \"6hr\", \"day\"]:\n        day_start, day_end = \"0101\", \"1231\"\n    elif freq == \"mon\":\n        day_start, day_end = \"01\", \"12\"\n    elif freq == \"sea\":\n        day_start, day_end = \"12\", \"11\"\n    else:\n        raise ValueError(f\"Invalid frequency: {freq}\")\n\n    if year_start is None:\n        year_start = \"*\"  # type: ignore[assignment]\n    if year_end is None:\n        year_end = \"*\"  # type: ignore[assignment]\n\n    return f\"{variable}_{domain}_{gcm_model}_{experiment}_{ensemble}_{rcm_model}*_{rcm_run}_{freq}_{year_start}{day_start}-{year_end}{day_end}\"\n</code></pre> <ol> <li> <p>Diez-Sierra J, Iturbide M, Guti\u00e9rrez JM, et al (2022) The Worldwide C3S CORDEX Grand Ensemble: A Major Contribution to Assess Regional Climate Change in the IPCC AR6 Atlas. Bulletin of the American Meteorological Society 103:E2804--E2826. https://doi.org/10.1175/BAMS-D-22-0111.1 \u21a9</p> </li> <li> <p>Jury MW, Prein AF, Truhetz H, Gobiet A (2015) Evaluation of CMIP5 models in the context of dynamical downscaling over europe. Journal of Climate 28:5575--5582. https://doi.org/10.1175/JCLI-D-14-00430.1 \u21a9</p> </li> <li> <p>Kotlarski S, L\u00fcthi D, Sch\u00e4r C (2015) The elevation dependency of 21st century european climate change: An RCM ensemble perspective. International Journal of Climatology 35:3902--3920. https://doi.org/10.1002/joc.4254 \u21a9</p> </li> <li> <p>Coppola E, Stocchi P, Pichelli E, et al (2021) Non-hydrostatic RegCM4 (RegCM4-NH): Model description and case studies over multiple domains. Geoscientific Model Development 14:7705--7723. https://doi.org/10.5194/gmd-14-7705-2021 \u21a9</p> </li> </ol>"},{"location":"cordex/#cordex.get_files","title":"<code>get_files(data_dir, variable, experiment, freq, year_start=None)</code>","text":"<p>Get file paths for the specified variable, experiment, frequency, and year range, for any given RCM model.</p> Source code in <code>clima_data/cordex.py</code> <pre><code>def get_files(\n    data_dir: str,\n    variable: str,\n    experiment: str,\n    freq: str,\n    year_start: int | None = None,\n) -&gt; list:\n    \"\"\"Get file paths for the specified variable, experiment, frequency, and year range, for any given RCM model.\"\"\"\n    dir_path = get_dirpath(data_dir, variable, experiment, freq)\n    if isinstance(year_start, int):\n        year_end = year_start + 4 if freq == \"day\" else year_start + 9\n    elif year_start is None:\n        year_end = None\n    else:\n        raise ValueError(\"year_start must be an integer or '*'\")\n    filename = get_filename(variable, \"*\", \"*\", experiment, freq, year_start, year_end)\n    return glob.glob(dir_path + f\"/{filename}.nc\")\n</code></pre>"},{"location":"cordex/#cordex.prune_invalid_tasks","title":"<code>prune_invalid_tasks(tasks)</code>","text":"<p>Prune tasks that are not available in ESGF.</p> <p>This function validates GCM-RCM combinations against ESGF availability for each experiment using the EURO-CORDEX ESGF table. Note that ESGF availability does not guarantee CDS API availability - some combinations may exist in ESGF but not be accessible through the CDS API.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>list</code> <p>List of task dictionaries with keys: variable, gcm_model, rcm_model, experiment, freq, year_start, year_end</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of pruned tasks with only valid combinations according to ESGF</p> Source code in <code>clima_data/cordex.py</code> <pre><code>def prune_invalid_tasks(tasks: list) -&gt; list:\n    \"\"\"\n    Prune tasks that are not available in ESGF.\n\n    This function validates GCM-RCM combinations against ESGF availability\n    for each experiment using the EURO-CORDEX ESGF table. Note that ESGF\n    availability does not guarantee CDS API availability - some combinations\n    may exist in ESGF but not be accessible through the CDS API.\n\n    Args:\n        tasks: List of task dictionaries with keys: variable, gcm_model, rcm_model, experiment, freq, year_start, year_end\n\n    Returns:\n        List of pruned tasks with only valid combinations according to ESGF\n    \"\"\"\n\n    # Group tasks by experiment, variable, and frequency for more efficient ESGF queries\n    tasks_by_criteria = defaultdict(list)\n    for task in tasks:\n        # Get ESGF frequency name (same as input for frequencies)\n        esgf_freq = task[\"freq\"]\n\n        criteria = (task[\"experiment\"], task[\"variable\"], esgf_freq)\n        tasks_by_criteria[criteria].append(task)\n\n    pruned_tasks = []\n    total_pruned = 0\n\n    for (experiment, variable, frequency), exp_tasks in tasks_by_criteria.items():\n        print(f\"\\nProcessing {len(exp_tasks)} tasks for: {experiment}, {variable}, {frequency}\")\n\n        # Get available combinations for this specific criteria set\n        available_combinations = get_esgf_combinations_for_experiment(\n            experiment, variable, frequency\n        )\n\n        if not available_combinations:\n            print(f\"No valid combinations found, skipping all {len(exp_tasks)} tasks\")\n            total_pruned += len(exp_tasks)\n            continue\n\n        exp_pruned, exp_kept = 0, 0\n\n        # Track which combinations we're looking for vs what's available\n        requested_combinations = set()\n\n        for task in exp_tasks:\n            gcm_norm = CordexNames.get_gcm_name(task[\"gcm_model\"], \"esgf\")\n            rcm_norm = CordexNames.get_rcm_name(task[\"rcm_model\"], \"esgf\")\n\n            # Create tuple to match the enhanced function's return format\n            requested_combo = (gcm_norm, rcm_norm, variable, frequency)\n            requested_combinations.add(requested_combo)\n\n            if requested_combo in available_combinations:\n                pruned_tasks.append(task)\n                exp_kept += 1\n            else:\n                exp_pruned += 1\n\n        print(f\"  Requested {len(requested_combinations)} unique combinations\")\n        print(f\"  Available {len(available_combinations)} combinations in ESGF\")\n        print(f\"  Kept {exp_kept} tasks, pruned {exp_pruned} tasks\")\n\n        # Show which combinations were requested but not available\n        missing_combinations = requested_combinations - available_combinations\n        if missing_combinations:\n            print(\"  Missing combinations:\")\n            for combo in sorted(missing_combinations):\n                print(f\"    {combo[0]} + {combo[1]} ({combo[2]}, {combo[3]})\")\n\n        total_pruned += exp_pruned\n\n    print(f\"ESGF pruning removed {total_pruned} tasks not available in ESGF\")\n    print(f\"Final: {len(pruned_tasks)} valid tasks out of {len(tasks)} original tasks\")\n\n    return pruned_tasks\n</code></pre>"},{"location":"full_bib/","title":"Bibliography","text":"<ol> <li> <p>Jury MW, Prein AF, Truhetz H, Gobiet A (2015) Evaluation of CMIP5 models in the context of dynamical downscaling over europe. Journal of Climate 28:5575--5582. https://doi.org/10.1175/JCLI-D-14-00430.1 \u21a9</p> </li> <li> <p>Kotlarski S, L\u00fcthi D, Sch\u00e4r C (2015) The elevation dependency of 21st century european climate change: An RCM ensemble perspective. International Journal of Climatology 35:3902--3920. https://doi.org/10.1002/joc.4254 \u21a9</p> </li> <li> <p>Coppola E, Stocchi P, Pichelli E, et al (2021) Non-hydrostatic RegCM4 (RegCM4-NH): Model description and case studies over multiple domains. Geoscientific Model Development 14:7705--7723. https://doi.org/10.5194/gmd-14-7705-2021 \u21a9</p> </li> <li> <p>Diez-Sierra J, Iturbide M, Guti\u00e9rrez JM, et al (2022) The Worldwide C3S CORDEX Grand Ensemble: A Major Contribution to Assess Regional Climate Change in the IPCC AR6 Atlas. Bulletin of the American Meteorological Society 103:E2804--E2826. https://doi.org/10.1175/BAMS-D-22-0111.1 \u21a9</p> </li> <li> <p>Copernicus Climate Change Service (2024) Copernicus climate data store \u21a9</p> </li> <li> <p>CORDEX Community (2024) CORDEX regional climate model data \u21a9</p> </li> <li> <p>EURO-CORDEX Community (2024) EURO-CORDEX: European domain regional climate projections \u21a9</p> </li> <li> <p>Bourgault P, Smith TJ, Huard D, et al (2024) Xclim: Climate services library \u21a9</p> </li> <li> <p>Hoyer S, Hamman J, Roos M, et al (2024) Xarray: N-d labeled arrays and datasets in python \u21a9</p> </li> <li> <p>Whitaker JS (2024) netcdf4-python: Python/numpy interface to the netCDF c library \u21a9</p> </li> <li> <p>Moon P (1940) Proposed standard solar-radiation curves for engineering use. Journal of the Franklin Institute 230:583--617. https://doi.org/10.1016/S0016-0032(40)90364-7 \u21a9</p> </li> <li> <p>McCree KJ (1972) The action spectrum, absorptance and quantum yield of photosynthesis in crop plants. Agricultural Meteorology 9:191--216. https://doi.org/10.1016/0002-1571(71)90022-7 \u21a9</p> </li> </ol>"},{"location":"indicators/","title":"Climatic Indicators","text":"<p>Climatic indicators are statistical measures derived from climate variables that quantify specific aspects of climate behavior, trends, and extremes. These indicators translate raw meteorological data into meaningful metrics for climate impact assessment, risk evaluation and adaptation planning.</p> <p>The <code>clima-data</code> library leverages the <code>xclim</code> library to compute a comprehensive suite of climatic indicators from CORDEX regional climate projections. These indicators range from basic statistics (e.g., annual mean temperature) to complex indices that capture extreme events (e.g., extreme precipitation return periods).</p>"},{"location":"indicators/#use-in-risk-analysis","title":"Use in Risk Analysis","text":"<p>Within the NATURE-DEMO project framework, these climatic indicators serve as hazard indices in the comprehensive risk analysis methodology developed to assess climate threats to critical infrastructure. By quantifying the frequency, intensity, and duration of climate extremes, these indicators enable the systematic evaluation of climate-related risks and inform the selection of nature-based solutions for infrastructure resilience.</p> <p>The indicators below are automatically generated from the <code>clima_data.indices</code> module, which provides standardized calculations following established climatological practices.</p>"},{"location":"indicators/#required-climate-variables","title":"Required Climate Variables","text":"<p>The following climate variables are automatically recognized by the system when computing indicators:</p> Variable Description Units <code>pr</code> Mean precipitation flux kg m\u207b\u00b2 s\u207b\u00b9 <code>tas</code> Near-surface air temperature K <code>tasmin</code> Daily minimum near-surface air temperature K <code>tasmax</code> Daily maximum near-surface air temperature K <code>hurs</code> Near-surface relative humidity % <code>sfcWind</code> Near-surface wind speed m s\u207b\u00b9 <code>ps</code> Surface air pressure Pa <code>rsds</code> Surface downwelling shortwave radiation W m\u207b\u00b2 <p>For the complete list of available CORDEX variables with detailed descriptions, see the CORDEX Variables section.</p>"},{"location":"indicators/#list-of-climatic-indicators","title":"List of climatic indicators","text":""},{"location":"indicators/#indices.cdd","title":"<code>cdd(pr)</code>","text":"<p>Maximum consecutive dry days</p> <p>Maximum number of consecutive days with precipitation below 1 mm/day.</p> Metadata Value Identifier cdd Units days Frequency YS Standard Name number_of_days_with_lwe_thickness_of_precipitation_amount_below_threshold <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Maximum consecutive dry days.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def cdd(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Maximum consecutive dry days**\n\n    Maximum number of consecutive days with precipitation below 1 mm/day.\n\n    | Metadata      | Value                                                           |\n    |-------------- |-----------------------------------------------------------------|\n    | Identifier    | cdd                                                             |\n    | Units         | days                                                            |\n    | Frequency     | YS                                                              |\n    | Standard Name | number_of_days_with_lwe_thickness_of_precipitation_amount_below_threshold |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Maximum consecutive dry days.\n    \"\"\"\n    return xa.maximum_consecutive_dry_days(pr, thresh=\"1 mm/day\", freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.cwd","title":"<code>cwd(pr)</code>","text":"<p>Maximum consecutive wet days</p> <p>Maximum number of consecutive days with precipitation above 1 mm/day.</p> Metadata Value Identifier cwd Units days Frequency YS Standard Name number_of_days_with_lwe_thickness_of_precipitation_amount_at_or_above_threshold <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Maximum consecutive wet days.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def cwd(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Maximum consecutive wet days**\n\n    Maximum number of consecutive days with precipitation above 1 mm/day.\n\n    | Metadata      | Value                                                           |\n    |-------------- |-----------------------------------------------------------------|\n    | Identifier    | cwd                                                             |\n    | Units         | days                                                            |\n    | Frequency     | YS                                                              |\n    | Standard Name | number_of_days_with_lwe_thickness_of_precipitation_amount_at_or_above_threshold |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Maximum consecutive wet days.\n    \"\"\"\n    return xa.maximum_consecutive_wet_days(pr, thresh=\"1 mm/day\", freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.hi35","title":"<code>hi35(tas, hurs)</code>","text":"<p>Yearly days with heat index &gt; 35\u00b0C</p> <p>Number of days per year with heat index (perceived temperature) &gt; 35\u00b0C.</p> Metadata Value Identifier hi35 Units days Frequency YS Standard Name number_of_days_with_air_temperature_above_threshold <p>Parameters:</p> Name Type Description Default <code>tas</code> <code>DataArray</code> <p>Air temperature (as an xarray DataArray).</p> required <code>hurs</code> <code>DataArray</code> <p>Relative humidity (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Number of days with heat index &gt; 35\u00b0C.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def hi35(tas: xr.DataArray, hurs: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Yearly days with heat index &gt; 35\u00b0C**\n\n    Number of days per year with heat index (perceived temperature) &gt; 35\u00b0C.\n\n    | Metadata      | Value                                         |\n    |-------------- |-----------------------------------------------|\n    | Identifier    | hi35                                          |\n    | Units         | days                                          |\n    | Frequency     | YS                                            |\n    | Standard Name | number_of_days_with_air_temperature_above_threshold |\n\n    Args:\n        tas: Air temperature (as an xarray DataArray).\n        hurs: Relative humidity (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Number of days with heat index &gt; 35\u00b0C.\n    \"\"\"\n    hi = xa.heat_index(tas=tas, hurs=hurs)\n    return (hi &gt; 35).resample(time=\"YS\").sum(dim=\"time\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.hurs40_days","title":"<code>hurs40_days(hurs)</code>","text":"<p>Annual days with relative humidity under 40%</p> <p>Number of days per year with daily relative humidity below 40%. Low humidity conditions can cause stress for both humans and plants.</p> Metadata Value Identifier hurs40_days Units days Frequency YS Standard Name number_of_days_with_relative_humidity_below_threshold <p>Parameters:</p> Name Type Description Default <code>hurs</code> <code>DataArray</code> <p>Relative humidity (as an xarray DataArray in %).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Number of days per year with RH &lt; 40%.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def hurs40_days(hurs: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual days with relative humidity under 40%**\n\n    Number of days per year with daily relative humidity below 40%.\n    Low humidity conditions can cause stress for both humans and plants.\n\n    | Metadata      | Value                                         |\n    |-------------- |-----------------------------------------------|\n    | Identifier    | hurs40_days                                   |\n    | Units         | days                                          |\n    | Frequency     | YS                                            |\n    | Standard Name | number_of_days_with_relative_humidity_below_threshold |\n\n    Args:\n        hurs: Relative humidity (as an xarray DataArray in %).\n\n    Returns:\n        xarray.DataArray: Number of days per year with RH &lt; 40%.\n    \"\"\"\n    return (hurs &lt; 40).resample(time=\"YS\").sum(dim=\"time\")\n</code></pre>"},{"location":"indicators/#indices.hurs_year","title":"<code>hurs_year(hurs)</code>","text":"<p>Annual mean relative humidity</p> <p>Mean of daily relative humidity aggregated yearly.</p> Metadata Value Identifier hurs Units % Frequency YS Standard Name relative_humidity <p>Parameters:</p> Name Type Description Default <code>hurs</code> <code>DataArray</code> <p>Relative humidity (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual mean relative humidity.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def hurs_year(hurs: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual mean relative humidity**\n\n    Mean of daily relative humidity aggregated yearly.\n\n    | Metadata      | Value           |\n    |-------------- |-----------------|\n    | Identifier    | hurs            |\n    | Units         | %               |\n    | Frequency     | YS              |\n    | Standard Name | relative_humidity|\n\n    Args:\n        hurs: Relative humidity (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Annual mean relative humidity.\n    \"\"\"\n    return hurs.resample(time=\"YS\").mean()\n</code></pre>"},{"location":"indicators/#indices.par_plant_level","title":"<code>par_plant_level(rsds, par_fraction=0.45)</code>","text":"<p>Photosynthetically active radiation at plant level</p> <p>Calculate photosynthetically active radiation (PAR) at plant level, assuming full sunlight conditions without canopy shading effects.</p> <p>The conversion uses two established constants: - PAR fraction of 0.45: Approximately 45% of solar radiation falls within the   photosynthetically active range (400-700 nm), as established by Moon (1940) - Conversion factor of 4.57 \u03bcmol/J: Standard factor established by McCree (1972)   to convert energy-based irradiance (W/m\u00b2) to photon flux density (\u03bcmol/m\u00b2/s)</p> Metadata Value Identifier par_plant_level Units \u03bcmol m-2 s-1 Frequency YS Standard Name photosynthetically_active_radiation_at_plant_level <p>Parameters:</p> Name Type Description Default <code>rsds</code> <code>DataArray</code> <p>Surface downwelling shortwave radiation (as an xarray DataArray in W/m\u00b2).</p> required <code>par_fraction</code> <code>float</code> <p>Fraction of solar radiation that is PAR (default: 0.45).</p> <code>0.45</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual mean PAR at plant level in \u03bcmol/m\u00b2/s.</p> References <p>Moon, P. (1940). Proposed standard solar-radiation curves for engineering use. Journal of the Franklin Institute, 230(5), 583-617.</p> <p>McCree, K. J. (1972). The action spectrum, absorptance and quantum yield of photosynthesis in crop plants. Agricultural Meteorology, 9, 191-216.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def par_plant_level(rsds: xr.DataArray, par_fraction: float = 0.45) -&gt; xr.DataArray:\n    \"\"\"**Photosynthetically active radiation at plant level**\n\n    Calculate photosynthetically active radiation (PAR) at plant level,\n    assuming full sunlight conditions without canopy shading effects.\n\n    The conversion uses two established constants:\n    - PAR fraction of 0.45: Approximately 45% of solar radiation falls within the\n      photosynthetically active range (400-700 nm), as established by Moon (1940)\n    - Conversion factor of 4.57 \u03bcmol/J: Standard factor established by McCree (1972)\n      to convert energy-based irradiance (W/m\u00b2) to photon flux density (\u03bcmol/m\u00b2/s)\n\n    | Metadata      | Value                                         |\n    |-------------- |-----------------------------------------------|\n    | Identifier    | par_plant_level                               |\n    | Units         | \u03bcmol m-2 s-1                                  |\n    | Frequency     | YS                                            |\n    | Standard Name | photosynthetically_active_radiation_at_plant_level |\n\n    Args:\n        rsds: Surface downwelling shortwave radiation (as an xarray DataArray in W/m\u00b2).\n        par_fraction: Fraction of solar radiation that is PAR (default: 0.45).\n\n    Returns:\n        xarray.DataArray: Annual mean PAR at plant level in \u03bcmol/m\u00b2/s.\n\n    References:\n        Moon, P. (1940). Proposed standard solar-radiation curves for engineering use.\n        Journal of the Franklin Institute, 230(5), 583-617.\n\n        McCree, K. J. (1972). The action spectrum, absorptance and quantum yield of\n        photosynthesis in crop plants. Agricultural Meteorology, 9, 191-216.\n    \"\"\"\n    # Convert solar radiation to PAR\n    # Conversion factor: W/m\u00b2 to \u03bcmol/m\u00b2/s for PAR\n    par = rsds * par_fraction * 4.57\n\n    # Calculate annual mean\n    return par.resample(time=\"YS\").mean()\n</code></pre>"},{"location":"indicators/#indices.prcptot_year","title":"<code>prcptot_year(pr)</code>","text":"<p>Total yearly precipitation (solid and liquid)</p> <p>Total yearly accumulated precipitation (solid and liquid).</p> Metadata Value Identifier prcptot Units mm year-1 Frequency YS Standard Name lwe_thickness_of_precipitation_amount <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Total yearly accumulated precipitation.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def prcptot_year(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Total yearly precipitation (solid and liquid)**\n\n    Total yearly accumulated precipitation (solid and liquid).\n\n    | Metadata      | Value                                   |\n    |-------------- |-----------------------------------------|\n    | Identifier    | prcptot                                 |\n    | Units         | mm year-1                               |\n    | Frequency     | YS                                      |\n    | Standard Name | lwe_thickness_of_precipitation_amount   |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Total yearly accumulated precipitation.\n    \"\"\"\n    return xa.precip_accumulation(pr=pr, freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.rx1day","title":"<code>rx1day(pr)</code>","text":"<p>Maximum 1-day precipitation amount</p> <p>Maximum precipitation amount over a single day.</p> Metadata Value Identifier rx1day Units mm day-1 Frequency YS Standard Name maximum_1_day_precipitation_amount <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Maximum 1-day precipitation amount.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def rx1day(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Maximum 1-day precipitation amount**\n\n    Maximum precipitation amount over a single day.\n\n    | Metadata      | Value                                   |\n    |-------------- |-----------------------------------------|\n    | Identifier    | rx1day                                  |\n    | Units         | mm day-1                                |\n    | Frequency     | YS                                      |\n    | Standard Name | maximum_1_day_precipitation_amount      |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Maximum 1-day precipitation amount.\n    \"\"\"\n    return xa.max_1day_precipitation_amount(pr, freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.rx1day_rp","title":"<code>rx1day_rp(pr)</code>","text":"<p>100-year return level of rx1day</p> <p>Return level of maximum 1-day precipitation for periods of 2 to 100 years.</p> Metadata Value Identifier rx1day_rp Units mm day-1 Standard Name maximum_1_day_precipitation_amount_X_year_return_period <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Computed return levels as an xarray.DataArray.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def rx1day_rp(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**100-year return level of rx1day**\n\n    Return level of maximum 1-day precipitation for periods of 2 to 100 years.\n\n    | Metadata      | Value                                                   |\n    |-------------- |---------------------------------------------------------|\n    | Identifier    | rx1day_rp                                               |\n    | Units         | mm day-1                                                |\n    | Standard Name | maximum_1_day_precipitation_amount_X_year_return_period |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        Computed return levels as an xarray.DataArray.\n    \"\"\"\n    rx1day_ = rx1day(pr)\n    results = frequency_analysis(\n        rx1day_,\n        mode=\"max\",\n        t=[2, 5, 10, 25, 50, 100, 200, 500],\n        dist=\"genextreme\",\n        freq=\"YS\",\n        method=\"ML\",\n    )\n    return results  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.rx5day","title":"<code>rx5day(pr)</code>","text":"<p>Maximum 5-day precipitation amount</p> <p>Maximum precipitation amount over a single day.</p> Metadata Value Identifier rx5day Units mm day-1 Frequency YS Standard Name maximum_5_day_precipitation_amount <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Maximum 5-day precipitation amount.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def rx5day(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Maximum 5-day precipitation amount**\n\n    Maximum precipitation amount over a single day.\n\n    | Metadata      | Value                                   |\n    |-------------- |-----------------------------------------|\n    | Identifier    | rx5day                                  |\n    | Units         | mm day-1                                |\n    | Frequency     | YS                                      |\n    | Standard Name | maximum_5_day_precipitation_amount      |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Maximum 5-day precipitation amount.\n    \"\"\"\n    return xa.max_n_day_precipitation_amount(pr, window=5, freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.rx5day_rp","title":"<code>rx5day_rp(pr)</code>","text":"<p>100-year return level of rx5day</p> <p>Return level of maximum 5-day precipitation for periods of 2 to 100 years.</p> Metadata Value Identifier rx5day_rp Units mm day-1 Standard Name maximum_5_day_precipitation_amount_X_year_return_period <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Computed return levels as an xarray.DataArray.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def rx5day_rp(pr: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**100-year return level of rx5day**\n\n    Return level of maximum 5-day precipitation for periods of 2 to 100 years.\n\n    | Metadata      | Value                                                   |\n    |-------------- |---------------------------------------------------------|\n    | Identifier    | rx5day_rp                                               |\n    | Units         | mm day-1                                                |\n    | Standard Name | maximum_5_day_precipitation_amount_X_year_return_period |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n\n    Returns:\n        Computed return levels as an xarray.DataArray.\n    \"\"\"\n    rx5day_ = rx5day(pr)\n    results = frequency_analysis(\n        rx5day_,\n        mode=\"max\",\n        t=[2, 5, 10, 25, 50, 100, 200, 500],\n        dist=\"genextreme\",\n        freq=\"YS\",\n        method=\"ML\",\n    )\n    return results  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.solidprcptot_winter","title":"<code>solidprcptot_winter(pr, tas)</code>","text":"<p>Winter months accumulated solid precipitation (DJF)</p> <p>Total accumulated solid precipitation during winter months (Dec-Jan-Feb).</p> Metadata Value Identifier solidprcptot Units mm season-1 Frequency QS-DEC Standard Name lwe_thickness_of_snowfall_amount <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <code>tas</code> <code>DataArray</code> <p>Air temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Accumulated solid precipitation during winter months.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def solidprcptot_winter(pr: xr.DataArray, tas: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Winter months accumulated solid precipitation (DJF)**\n\n    Total accumulated solid precipitation during winter months (Dec-Jan-Feb).\n\n    | Metadata      | Value                           |\n    |-------------- |---------------------------------|\n    | Identifier    | solidprcptot                    |\n    | Units         | mm season-1                    |\n    | Frequency     | QS-DEC                         |\n    | Standard Name | lwe_thickness_of_snowfall_amount |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n        tas: Air temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Accumulated solid precipitation during winter months.\n    \"\"\"\n    return xa.solid_precip_accumulation(pr=pr, tas=tas, thresh=\"0 degC\", freq=\"QS-DEC\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.solidprcptot_year","title":"<code>solidprcptot_year(pr, tas)</code>","text":"<p>Annual accumulated solid precipitation</p> <p>Total accumulated solid precipitation per year.</p> Metadata Value Identifier solidprcptot Units mm year-1 Frequency YS Standard Name lwe_thickness_of_snowfall_amount <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Precipitation (as an xarray DataArray).</p> required <code>tas</code> <code>DataArray</code> <p>Air temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual accumulated solid precipitation.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def solidprcptot_year(pr: xr.DataArray, tas: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual accumulated solid precipitation**\n\n    Total accumulated solid precipitation per year.\n\n    | Metadata      | Value                           |\n    |-------------- |---------------------------------|\n    | Identifier    | solidprcptot                    |\n    | Units         | mm year-1                      |\n    | Frequency     | YS                             |\n    | Standard Name | lwe_thickness_of_snowfall_amount |\n\n    Args:\n        pr: Precipitation (as an xarray DataArray).\n        tas: Air temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Annual accumulated solid precipitation.\n    \"\"\"\n    return xa.solid_precip_accumulation(pr=pr, tas=tas, thresh=\"0 degC\", freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.spei3_severe_prob","title":"<code>spei3_severe_prob(pr, tas, window=3, severe_threshold=-1.5)</code>","text":"<p>Annual probability of experiencing severe agricultural drought (SPEI-3)</p> <p>Calculate the annual probability of experiencing severe drought conditions based on the 3-month Standardized Precipitation Evapotranspiration Index (SPEI-3). SPEI-3 is specifically designed for agricultural drought monitoring and captures seasonal water-balance conditions without excessive temporal smoothing.</p> Metadata Value Identifier spei3_severe_prob Units probability (0-1) Frequency YS Standard Name probability_of_severe_agricultural_drought_occurrence <p>Parameters:</p> Name Type Description Default <code>pr</code> <code>DataArray</code> <p>Monthly precipitation (as an xarray DataArray in mm/month).</p> required <code>tas</code> <code>DataArray</code> <p>Monthly mean temperature (as an xarray DataArray in K or \u00b0C).</p> required <code>window</code> <code>int</code> <p>Time window for SPEI calculation in months (default: 3 for agricultural drought).</p> <code>3</code> <code>severe_threshold</code> <code>float</code> <p>SPEI threshold for severe drought (default: -1.5).</p> <code>-1.5</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual probability of severe agricultural drought occurrence (0-1).</p> Notes <p>SPEI-3 (3-month accumulation period) is the standard timescale for agricultural drought assessment, capturing soil moisture conditions and seasonal water balance without the smoothing effects of longer timescales.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def spei3_severe_prob(\n    pr: xr.DataArray, tas: xr.DataArray, window: int = 3, severe_threshold: float = -1.5\n) -&gt; xr.DataArray:\n    \"\"\"**Annual probability of experiencing severe agricultural drought (SPEI-3)**\n\n    Calculate the annual probability of experiencing severe drought conditions\n    based on the 3-month Standardized Precipitation Evapotranspiration Index (SPEI-3).\n    SPEI-3 is specifically designed for agricultural drought monitoring and captures\n    seasonal water-balance conditions without excessive temporal smoothing.\n\n    | Metadata      | Value                                         |\n    |-------------- |-----------------------------------------------|\n    | Identifier    | spei3_severe_prob                             |\n    | Units         | probability (0-1)                             |\n    | Frequency     | YS                                            |\n    | Standard Name | probability_of_severe_agricultural_drought_occurrence |\n\n    Args:\n        pr: Monthly precipitation (as an xarray DataArray in mm/month).\n        tas: Monthly mean temperature (as an xarray DataArray in K or \u00b0C).\n        window: Time window for SPEI calculation in months (default: 3 for agricultural drought).\n        severe_threshold: SPEI threshold for severe drought (default: -1.5).\n\n    Returns:\n        xarray.DataArray: Annual probability of severe agricultural drought occurrence (0-1).\n\n    Notes:\n        SPEI-3 (3-month accumulation period) is the standard timescale for agricultural\n        drought assessment, capturing soil moisture conditions and seasonal water balance\n        without the smoothing effects of longer timescales.\n    \"\"\"\n    import gc\n\n    # Calculate water budget using xclim with MB05 method\n    wb = xi.water_budget(pr=pr, tas=tas, method=\"MB05\")\n\n    # Optimized chunking for SPEI: realizations are independent, can process more together\n    # 30x30 spatial chunks = 900 grid points per chunk\n    # Process 4 realizations together since SPEI computation is independent across realizations\n    wb = wb.chunk({\"time\": -1, \"x\": 30, \"y\": 30, \"realization\": 4})\n\n    # Force garbage collection before heavy computation\n    gc.collect()\n\n    # Calculate SPEI-3 using xclim's built-in function\n    # The warning about rechunking is expected - xclim needs to redistribute data\n    spei = xi.standardized_precipitation_evapotranspiration_index(wb=wb, freq=\"MS\", window=window)\n\n    # Calculate annual probability of severe drought\n    severe_drought = spei &lt;= severe_threshold\n    annual_prob = severe_drought.resample(time=\"YS\").mean(dim=\"time\")\n\n    # Use persist() instead of compute() to keep it distributed but computed\n    annual_prob = annual_prob.persist()\n\n    # Force cleanup of intermediate variables\n    del wb, spei, severe_drought\n    gc.collect()\n\n    return annual_prob  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.tg_year","title":"<code>tg_year(tas)</code>","text":"<p>Annual mean average temperature</p> <p>Mean of daily mean temperature aggregated yearly.</p> Metadata Value Identifier tg Units K Frequency YS Standard Name air_temperature <p>Parameters:</p> Name Type Description Default <code>tas</code> <code>DataArray</code> <p>Air temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual mean temperature.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def tg_year(tas: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual mean average temperature**\n\n    Mean of daily mean temperature aggregated yearly.\n\n    | Metadata      | Value           |\n    |-------------- |-----------------|\n    | Identifier    | tg              |\n    | Units         | K               |\n    | Frequency     | YS              |\n    | Standard Name | air_temperature |\n\n    Args:\n        tas: Air temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Annual mean temperature.\n    \"\"\"\n    return xa.tg_mean(tas=tas, freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.tn20","title":"<code>tn20(tasmin)</code>","text":"<p>Days with minimum temperature &lt; -20\u00b0C</p> <p>Average number of days per year with daily minimum temperature &lt; -20\u00b0C.</p> Metadata Value Identifier tn20 Units days Frequency YS Standard Name number_of_days_with_air_temperature_below_threshold <p>Parameters:</p> Name Type Description Default <code>tasmin</code> <code>DataArray</code> <p>Daily minimum temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Number of days per year with min temp &lt; -20\u00b0C.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def tn20(tasmin: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Days with minimum temperature &lt; -20\u00b0C**\n\n    Average number of days per year with daily minimum temperature &lt; -20\u00b0C.\n\n    | Metadata      | Value                                         |\n    |-------------- |-----------------------------------------------|\n    | Identifier    | tn20                                          |\n    | Units         | days                                          |\n    | Frequency     | YS                                            |\n    | Standard Name | number_of_days_with_air_temperature_below_threshold |\n\n    Args:\n        tasmin: Daily minimum temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Number of days per year with min temp &lt; -20\u00b0C.\n    \"\"\"\n    return xa.tn_days_below(tasmin, thresh=\"-20.0 degC\", freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.tn_year","title":"<code>tn_year(tasmin)</code>","text":"<p>Annual mean minimum temperature</p> <p>Mean of daily minimum temperature aggregated yearly.</p> Metadata Value Identifier tn Units K Frequency YS Standard Name air_temperature <p>Parameters:</p> Name Type Description Default <code>tasmin</code> <code>DataArray</code> <p>Daily minimum temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual mean minimum temperature.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def tn_year(tasmin: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual mean minimum temperature**\n\n    Mean of daily minimum temperature aggregated yearly.\n\n    | Metadata      | Value           |\n    |-------------- |-----------------|\n    | Identifier    | tn              |\n    | Units         | K               |\n    | Frequency     | YS              |\n    | Standard Name | air_temperature |\n\n    Args:\n        tasmin: Daily minimum temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Annual mean minimum temperature.\n    \"\"\"\n    return xa.tn_mean(tasmin=tasmin, freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.tx40","title":"<code>tx40(tasmax)</code>","text":"<p>Annual days with maximum temperature &gt; 40\u00b0C</p> <p>Average number of days per year with daily maximum temperature &gt; 40\u00b0C.</p> Metadata Value Identifier tx40 Units days Frequency YS Standard Name number_of_days_with_air_temperature_above_threshold <p>Parameters:</p> Name Type Description Default <code>tasmax</code> <code>DataArray</code> <p>Daily maximum temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Number of days per year with max temp &gt; 40\u00b0C.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def tx40(tasmax: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual days with maximum temperature &gt; 40\u00b0C**\n\n    Average number of days per year with daily maximum temperature &gt; 40\u00b0C.\n\n    | Metadata      | Value                                         |\n    |-------------- |-----------------------------------------------|\n    | Identifier    | tx40                                          |\n    | Units         | days                                          |\n    | Frequency     | YS                                            |\n    | Standard Name | number_of_days_with_air_temperature_above_threshold |\n\n    Args:\n        tasmax: Daily maximum temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Number of days per year with max temp &gt; 40\u00b0C.\n    \"\"\"\n    return xa.tx_days_above(tasmax, thresh=\"40.0 degC\", freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.tx_year","title":"<code>tx_year(tasmax)</code>","text":"<p>Annual mean maximum temperature</p> <p>Mean of daily maximum temperature aggregated yearly.</p> Metadata Value Identifier tx Units K Frequency YS Standard Name air_temperature <p>Parameters:</p> Name Type Description Default <code>tasmax</code> <code>DataArray</code> <p>Daily maximum temperature (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Annual mean maximum temperature.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def tx_year(tasmax: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Annual mean maximum temperature**\n\n    Mean of daily maximum temperature aggregated yearly.\n\n    | Metadata      | Value           |\n    |-------------- |-----------------|\n    | Identifier    | tx              |\n    | Units         | K               |\n    | Frequency     | YS              |\n    | Standard Name | air_temperature |\n\n    Args:\n        tasmax: Daily maximum temperature (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Annual mean maximum temperature.\n    \"\"\"\n    return xa.tx_mean(tasmax=tasmax, freq=\"YS\")  # type: ignore[no-any-return]\n</code></pre>"},{"location":"indicators/#indices.vpd","title":"<code>vpd(tas, hurs)</code>","text":"<p>Vapor pressure deficit</p> <p>Annual vapor pressure deficit.</p> Metadata Value Identifier vpd Units Pa Frequency YS Standard Name vapor_pressure_deficit <p>Parameters:</p> Name Type Description Default <code>tas</code> <code>DataArray</code> <p>Air temperature (as an xarray DataArray).</p> required <code>hurs</code> <code>DataArray</code> <p>Relative humidity (as an xarray DataArray).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>xarray.DataArray: Vapor pressure deficit.</p> Source code in <code>clima_data/indices.py</code> <pre><code>def vpd(tas: xr.DataArray, hurs: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"**Vapor pressure deficit**\n\n    Annual vapor pressure deficit.\n\n    | Metadata      | Value           |\n    |-------------- |-----------------|\n    | Identifier    | vpd             |\n    | Units         | Pa              |\n    | Frequency     | YS              |\n    | Standard Name | vapor_pressure_deficit |\n\n    Args:\n        tas: Air temperature (as an xarray DataArray).\n        hurs: Relative humidity (as an xarray DataArray).\n\n    Returns:\n        xarray.DataArray: Vapor pressure deficit.\n    \"\"\"\n    return xa.vapor_pressure_deficit(tas=tas, hurs=hurs).resample(time=\"YS\").mean()  # type: ignore[no-any-return]\n</code></pre>"},{"location":"assets/cordex_variables_notes/","title":"Cordex variables notes","text":"<ul> <li>Units: Align with CORDEX/CDS specifications (e.g., <code>pr</code> in <code>kg.m\u207b\u00b2.s\u207b\u00b9</code>, <code>tas</code> in <code>K</code>)</li> <li>Temporal resolution: Variables are available at 3-hourly, daily, monthly, or seasonal frequencies, which in the CDS API are indicates as <code>3hr</code>, <code>daily_mean</code>, <code>monthly_mean</code>, <code>seasonal_mean</code>, respectively (non-European domains only include daily data).</li> <li>Static variables: <code>sftlf</code> (land area fraction) and <code>orog</code> (topography) are time-independent</li> <li>Standard Names: Standard naming following CF conventions can be found in CORDEX Variable Requirements Table</li> </ul> <p>For further details, see the CORDEX Documentation.</p>"}]}